// Copyright (C) 2017 Joel Scoble
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation, version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program. If not, see <http://www.gnu.org/licenses/>.
//
// The log flags and other elemets come from stdlib's log package. This is the
// relevant copyright notice:
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package ezlog provides simple leveled log output using stdlib's log.Logger.
// A type Logger is defined with methods for leveled log line and formatted
// leveled log line output. For convenience, a 'standard' logger is available
// through the helper functions. The 'standard' logger's log level is LogError
// and writes output to stderr with LstdFlags.
//
// In addition to LogNone, which discards all log lines, three common log
// levels are supported: error (LogError), info (LogInfo), and debug
// (LogDebug). Any log lines that are for log levels higher than the logger's
// log level are discarded.
//
// Leveled log lines are written with the Error[f|ln], Info[f|ln], Debug[f|ln]
// methods. Aside from the leveled log lines, two other types of prefixed log
// lines can be written: Fatal[f|ln] and Panic[f|ln]. Log lines w/o levels can
// be written with the Print[f|ln] methods. These methods will always result in
// the log lines being written.
//
// On Fatal and Panic calls, Logger can run functions prior to os.Exit or
// panic. These functions are added using the AddFunc call and are expected to
// have a func() error signature. Any errors that may occur during the
// execution of these functions will be ignored.
//
// These functions can also be run by calling the Close method.
package ezlog

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"sync"
	"sync/atomic"
)

// These flags define which text to prefix to each log entry generated by the Logger.
const (
	// Bits or'ed together to control what's printed.
	// There is no control over the order they appear (the order listed
	// here) or the format they present (as described in the comments).
	// The prefix is followed by a colon only when Llongfile or Lshortfile
	// is specified.
	// For example, flags Ldate | Ltime (or LstdFlags) produce,
	//	2009/01/23 01:23:23 message
	// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
	//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

// Level: log levels.
type Level int32 // for sync.Atomic.Int32

const (
	LogNone  Level = iota + 1 // no logging
	LogError                  // log Error lines.
	LogInfo                   // log Info and Error lines.
	LogDebug                  // log Debug, Info, and Error lines.
	logFatal
	logPanic
)

func (l Level) String() string {
	return levelName[l]
}

// LevelStringType is the type of string output that will be used for the log
// level.
type LevelStringType int

const (
	Full  LevelStringType = iota // use the level's full name
	Short                        // use the level's short description
	Char                         // use the first character of the level's name
)

var levelChar = []string{
	LogNone:  "NONE:", // this is the fullword because it should never be used
	LogError: "E:",
	LogInfo:  "I:",
	LogDebug: "D:",
	logFatal: "F:",
	logPanic: "P:",
}

var levelShort = []string{
	LogNone:  "NONE:",
	LogError: "ERR:",
	LogInfo:  "INF:",
	LogDebug: "DBG:",
	logFatal: "FATAL:",
	logPanic: "PANIC:",
}

var levelName = []string{
	LogNone:  "NONE:",
	LogError: "ERROR:",
	LogInfo:  "INFO:",
	LogDebug: "DEBUG:",
	logFatal: "FATAL:",
	logPanic: "PANIC:",
}

// LevelByName gets the Level corresponding to s. A false will be returned if s
// doesn't match any Levels.
func LevelByName(s string) (level Level, ok bool) {
	v := strings.ToUpper(s)
	switch v {
	case "NONE":
		return LogNone, true
	case "ERROR":
		return LogError, true
	case "INFO":
		return LogInfo, true
	case "DEBUG":
		return LogDebug, true
	default:
		return 0, false
	}
}

// UnknownFlagError occurs when a string cannot be parsed into a log Flag.
type UnknownFlagError struct {
	S string // The string that could not be parsed to a valid Flag.
}

func (e UnknownFlagError) Error() string {
	return "unknown log flag: " + e.S
}

// ParseLogFlag returns the log Flag for s. A match is found when s is equal to
// either the name of a Flag constant or the name of a Flag constant without
// the leading 'l', e.g. both "lstdflags" and "stdflags" will return the value
// for the LstdFlags constant. The match is case-insensitve. Empty string is
// treated as wanting the default LstdFlags; returning LstdFlags. An
// UnknownFlagError is returned if no match for s is found.
func ParseLogFlag(s string) (l int, err error) {
	v := strings.ToLower(s)
	switch v {
	case "":
		return LstdFlags, nil
	case "ldate", "date":
		return Ldate, nil
	case "ltime", "time":
		return Ltime, nil
	case "lmicroseconds", "microseconds":
		return Lmicroseconds, nil
	case "llongfile", "longfile":
		return Llongfile, nil
	case "lshortfile", "shortfile":
		return Lshortfile, nil
	case "lutc", "utc":
		return LUTC, nil
	case "lstdflags", "stdflags":
		return LstdFlags, nil
	case "none":
		return 0, nil
	}
	return 0, UnknownFlagError{s}
}

// Logger generates leveled log lines of output to an io.Writer if the log
// level is <= the logger's level. This is safe for concurrent use.
type Logger struct {
	l          *log.Logger
	level      int32          // sync.AtomicInt32
	stringType int32          // sync.AtomicInt32
	funcs      []func() error // funcs to be run by Close
	mu         sync.Mutex     // this protects the funcs only
}

// New creates a new Logger. The level argument sets the Logger's log level.
// The levelStringType is what should be used for the level's name: the first
// character, Char, the short version, Short, or the full name, Full. The out
// argument sets the log data output destination. The prefix argument sets what
// each line will start with. The flag argument sets the logger's properties.
func New(level Level, levelStringType LevelStringType, out io.Writer, prefix string, flag int) *Logger {
	return &Logger{l: log.New(out, prefix, flag), level: int32(level), stringType: int32(levelStringType)}
}

// AddFunc adds a func to the logger that is to be run by the Close, Fatal, and
// Panic methods. Funcs will be run in the order they are added.
func (l *Logger) AddFunc(f func() error) {
	l.mu.Lock()
	l.funcs = append(l.funcs, f)
	l.mu.Unlock()
}

// Close runs any funcs that the logger was given. Any errors that occurs
// during the execution of these funcs are ignored as this is expected to occur
// immediately before the application exits.
func (l *Logger) Close() {
	l.mu.Lock()
	for _, f := range l.funcs {
		f()
	}
	l.mu.Unlock()
}

// Error writes an error line to the logger. If the logger's level is less than
// LogError, the line will be discarded. Arguments are handled in the manner of
// fmt.Print.
func (l *Logger) Error(v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogError) {
		return
	}
	v = append([]interface{}{l.levelString(LogError), " "}, v...)
	l.l.Output(2, fmt.Sprint(v...))
}

// Errorf writes an error line to the logger using the provided format and
// data. If the level is less than LogError, the line will be discarded.
// Arguments are handled in the manner of fmt.Printf.
func (l *Logger) Errorf(format string, v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogError) {
		return
	}
	l.l.Output(2, fmt.Sprintf(fmt.Sprintf("%s %s", l.levelString(LogError), format), v...))
}

// Errorln writes an error line to the logger. If the logger's level is less
// than LogError, the line will be discarded. Arguments are handled in the
// manner of fmt.Println.
func (l *Logger) Errorln(v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogError) {
		return
	}
	v = append([]interface{}{l.levelString(LogError)}, v...)
	l.l.Output(2, fmt.Sprintln(v...))
}

// Info writes an info entry to the logger. If the level is less than LogInfo,
// the line will be discarded. Arguments are handled in the manner of
// fmt.Print.
func (l *Logger) Info(v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogInfo) {
		return
	}
	v = append([]interface{}{l.levelString(LogInfo), " "}, v...)
	l.l.Output(2, fmt.Sprint(v...))
}

// Infof writes an info line to the logger using the provided format and data.
// If the level is less than LogInfo, the line will be discarded. Arguments are
// handled in the manner of fmt.Printf.
func (l *Logger) Infof(format string, v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogInfo) {
		return
	}
	l.l.Output(2, fmt.Sprintf(fmt.Sprintf("%s %s", l.levelString(LogInfo), format), v...))
}

// Infoln writes an info entry to the logger. If the level is less than
// LogInfo, the line will be discarded. Arguments are handled in the manner of
// fmt.Println.
func (l *Logger) Infoln(v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogInfo) {
		return
	}
	v = append([]interface{}{l.levelString(LogInfo)}, v...)
	l.l.Output(2, fmt.Sprintln(v...))
}

// Debug writes a debug line to the logger. If the level is less than LogDebug,
// the line will be discarded. Arguments are handled in the manner of
// fmt.Print.
func (l *Logger) Debug(v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogDebug) {
		return
	}
	v = append([]interface{}{l.levelString(LogDebug), " "}, v...)
	l.l.Output(2, fmt.Sprint(v...))
}

// Debugf writes a debug line to the logger using the provided format and data.
// If the level is less than LogDebug, the line will be discarded. Arguments
// are handled in the manner of fmt.Printf.
func (l *Logger) Debugf(format string, v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogDebug) {
		return
	}
	l.l.Output(2, fmt.Sprintf(fmt.Sprintf("%s %s", l.levelString(LogDebug), format), v...))
}

// Debugln writes a debug line to the logger. If the level is less than
// LogDebug, the line will be discarded. Arguments are handled in the manner of
// fmt.Println.
func (l *Logger) Debugln(v ...interface{}) {
	if atomic.LoadInt32(&l.level) < int32(LogDebug) {
		return
	}
	v = append([]interface{}{l.levelString(LogDebug)}, v...)
	l.l.Output(2, fmt.Sprintln(v...))
}

// Fatal writes a fatal line to the logger followed by a call to os.Exit(1).
// Arguments are handled in the manner of fmt.Print.
func (l *Logger) Fatal(v ...interface{}) {
	v = append([]interface{}{l.levelString(logFatal), " "}, v...)
	l.l.Output(2, fmt.Sprint(v...))
	l.Close()
	os.Exit(1)
}

// Fatalf writes a fatal line to the logger using the provided format and data
// followed by a call to os.Exit(1).
func (l *Logger) Fatalf(format string, v ...interface{}) {
	l.l.Output(2, fmt.Sprintf(fmt.Sprintf("%s %s", l.levelString(logFatal), format), v...))
	l.Close()
	os.Exit(1)
}

// Fatalln writes a fatal line to the logger followed by a call to os.Exit(1).
// Arguments are handled in the manner of fmt.Println.
func (l *Logger) Fatalln(v ...interface{}) {
	v = append([]interface{}{l.levelString(logFatal)}, v...)
	l.l.Output(2, fmt.Sprintln(v...))
	l.Close()
	os.Exit(1)
}

// Panic writes a panic line to the logger followed by a call to panic().
// Arguments are handled in the manner of fmt.Print.
func (l *Logger) Panic(v ...interface{}) {
	v = append([]interface{}{l.levelString(LogDebug), " "}, v...)
	s := fmt.Sprint(v...)
	l.l.Output(2, s)
	l.Close()
	panic(s)
}

// Panicf writes a panic line to the logger using the provided format and data
// followed by a call to panic().
func (l *Logger) Panicf(format string, v ...interface{}) {
	s := fmt.Sprintf(fmt.Sprintf("%s %s", l.levelString(logPanic), format), v...)
	l.l.Output(2, s)
	l.Close()
	panic(s)
}

// Panicln writes a panic line to the logger followed by a call to panic().
// Arguments are handled in the manner of fmt.Println.
func (l *Logger) Panicln(v ...interface{}) {
	v = append([]interface{}{l.levelString(LogDebug)}, v...)
	s := fmt.Sprintln(v...)
	l.l.Output(2, s)
	l.Close()
	panic(s)
}

// Print writes a log line to the logger. Unless the logger's level is LogNone,
// the line will always be written. Arguments are handled in the manner of
// fmt.Print.
func (l *Logger) Print(v ...interface{}) {
	if atomic.LoadInt32(&l.level) <= int32(LogNone) {
		return
	}
	l.l.Output(2, fmt.Sprint(v...))
}

// Printf writes a log line to the logger. Unless the logger's level is
// LogNone, the line will always be written. Arguments are handled in the
// manner of fmt.Printf.
func (l *Logger) Printf(format string, v ...interface{}) {
	if atomic.LoadInt32(&l.level) <= int32(LogNone) {
		return
	}
	l.l.Output(2, fmt.Sprintf(format, v...))
}

// Println writes a log line to the logger. Unless the logger's level is
// LogNone, the line will always be written. Arguments are handled in the
// manner of fmt.Println.
func (l *Logger) Println(v ...interface{}) {
	if atomic.LoadInt32(&l.level) <= int32(LogNone) {
		return
	}
	l.l.Output(2, fmt.Sprintln(v...))
}

// Flags returns the logger's output flags.
func (l *Logger) Flags() int {
	return l.l.Flags()
}

// SetFlags sets the logger's flags.
func (l *Logger) SetFlags(flags int) {
	l.l.SetFlags(flags)
}

// GetLevel returns the logger's level.
func (l *Logger) GetLevel() Level {
	return Level(atomic.LoadInt32(&l.level))
}

// SetLevel sets the maximum level for the logger's output. Any log lines
// whose levels are higher than the logger's level will be discarded.
func (l *Logger) SetLevel(i Level) {
	atomic.StoreInt32((*int32)(&l.level), int32(i))
}

// SetOutput sets the logger's output.
func (l *Logger) SetOutput(w io.Writer) {
	l.l.SetOutput(w)
}

// Prefix returns the logger's prefix.
func (l *Logger) Prefix() string {
	return l.l.Prefix()
}

// SetPrefix sets the logger's prefix.
func (l *Logger) SetPrefix(prefix string) {
	l.l.SetPrefix(prefix)
}

// GetLevelStringType returns what the logger is using for the error level
// name (string) in log lines.
func (l *Logger) GetLevelStringType() LevelStringType {
	return LevelStringType(atomic.LoadInt32(&l.stringType))
}

// SetLevelStringType sets what the logger should use for the level name
// (string) in log lines.
func (l *Logger) SetLevelStringType(v LevelStringType) {
	atomic.StoreInt32((*int32)(&l.stringType), int32(v))
}

func (l *Logger) levelString(i Level) string {
	v := LevelStringType(atomic.LoadInt32(&l.stringType))
	switch v {
	case Full:
		return levelName[i]
	case Char:
		return levelChar[i]
	case Short:
		return levelShort[i]
	}
	// unknown level results in an empty string
	return ""
}

var std = New(LogError, Full, os.Stderr, "", log.LstdFlags)

// AddFunc adds a func to the standard logger that is to be run by the Close,
// Fatal, and Panic methods. Funcs will be run in the order they are added.
func AddFunc(f func() error) {
	std.AddFunc(f)
}

// Close runs any funcs that standard logger was given. Any errors that occurs
// during the execution of these funcs are ignored as this is expected to occur
// immediately before the application exits.
func Close() {
	std.Close()
}

// Error writes an error entry to the standard logger. If the logger's level is
// less than LogError, the line will be discarded. Arguments are handled in the
// manner of fmt.Print.
func Error(v ...interface{}) {
	std.Error(v...)
}

// Errorf writes an error line to the standard logger using the provided format
// and data. If the level is less than LogError, the line will be discarded.
// Arguments are handled in the manner of fmt.Printf.
func Errorf(format string, v ...interface{}) {
	std.Errorf(format, v...)
}

// Errorln writes an error line to the standard logger. If the logger's level
// is less than LogError, the line will be discarded. Arguments are handled in
// the manner of fmt.Println.
func Errorln(v ...interface{}) {
	std.Errorln(v...)
}

// Info writes an info line to the standard logger. If the level is less than
// LogInfo, the line will be discarded. Arguments are handled in the manner of
// fmt.Print.
func Info(v ...interface{}) {
	std.Info(v...)
}

// Infof writes an info line to the standard logger using the provided format
// and data. If the level is less than LogInfo, the line will be discarded.
// Arguments are handled in the manner of fmt.Printf.
func Infof(format string, v ...interface{}) {
	std.Infof(format, v...)
}

// Infoln writes an info line to the standard logger. If the level is less than
// LogInfo, the line will be discarded. Arguments are handled in the manner of
// fmt.Println.
func Infoln(v ...interface{}) {
	std.Infoln(v...)
}

// Debug writes a debug line to the standard logger. If the level is less than
// LogDebug, the line will be discarded. Arguments are handled in the manner of
// fmt.Print.
func Debug(v ...interface{}) {
	std.Debug(v...)
}

// Debugf writes a debug line to the standard logger using the provided format
// and data. If the level is less than LogDebug, the line will be discarded.
// Arguments are handled in the manner of fmt.Printf.
func Debugf(format string, v ...interface{}) {
	std.Debugf(format, v...)
}

// Debugln writes a debug line to the stadard logger. If the level is less than
// LogDebug, the line will be discarded. Arguments are handled in the manner of
// fmt.Println.
func Debugln(v ...interface{}) {
	std.Debugln(v...)
}

// Fatal writes a fatal line to the standard logger followed by a call to
// os.Exit(1). Arguments are handled in the manner of fmt.Print.
func Fatal(v ...interface{}) {
	std.Fatal(v...)
}

// Fatalf writes a fatal line to the standard logger using the provided format
// and data followed by a call to os.Exit(1).
func Fatalf(format string, v ...interface{}) {
	std.Fatalf(format, v...)
}

// Fatalln writes a fatal line to the standard logger followed by a call to
// os.Exit(1). Arguments are handled in the manner of fmt.Println.
func Fatalln(v ...interface{}) {
	std.Fatalln(v...)
}

// Panic writes a panic line to the standard logger followed by a call to
// panic(). Arguments are handled in the manner of fmt.Print.
func Panic(v ...interface{}) {
	std.Panic(v...)
}

// Panicf writes a panic line to the standard logger using the provided format
// and data followed by a call to panic(). Arguments are handled in the manner
// of fmt.Printf.
func Panicf(format string, v ...interface{}) {
	std.Panicf(format, v...)
}

// Panicln writes a panic line to the standard logger followed by a call to
// panic(). Arguments are handled in the manner of fmt.Println.
func Panicln(v ...interface{}) {
	std.Panicln(v...)
}

// Print writes a log line to the standard logger. Unless the logger's level is
// LogNone, the line will always be written. Arguments are handled in the
// manner of fmt.Print.
func Print(v ...interface{}) {
	std.Print(v...)
}

// Printf writes a log line to the standard logger. Unless the logger's level
// is LogNone, the line will always be written. Arguments are handled in the
// manner of fmt.Printf.
func Printf(format string, v ...interface{}) {
	std.Printf(format, v...)
}

// Println writes a log line to the standard logger. Unless the logger's level
// is LogNone, the line will always be written. Arguments are handled in the
// manner of fmt.Println.
func Println(v ...interface{}) {
	std.Println(v...)
}

// Flags returns the standard logger's output flags.
func Flags() int {
	return std.l.Flags()
}

// SetFlags sets the standard logger's flags.
func SetFlags(flags int) {
	std.l.SetFlags(flags)
}

// GetLevel returns the standard logger's level.
func GetLevel() Level {
	return std.GetLevel()
}

// SetLevel sets the maximum level for the standard logger's log output. Any
// log lines whose levels are higher than the standard logger's level will be
// discarded.
func SetLevel(i Level) {
	std.SetLevel(i)
}

// SetOutput sets the standard logger's output destination.
func SetOutput(w io.Writer) {
	std.SetOutput(w)
}

// Prefix returns the standrd logger's prefix.
func Prefix() string {
	return std.l.Prefix()
}

// SetPrefix sets the standard logger's prefix.
func SetPrefix(prefix string) {
	std.l.SetPrefix(prefix)
}

// GetLevelStringType returns what the standard logger is using for the error
// level name (string) in log lines.
func GetLevelStringType() LevelStringType {
	return std.GetLevelStringType()
}

// SetLevelStringType sets what the standard logger should use for the level
// name (string) in log lines.
func SetLevelStringType(v LevelStringType) {
	std.SetLevelStringType(v)
}
