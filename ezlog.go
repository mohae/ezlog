// Copyright (C) 2017 Joel Scoble
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by the Free
// Software Foundation, version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
// more details.
//
// You should have received a copy of the GNU General Public License along with
// this program. If not, see <http://www.gnu.org/licenses/>.
//
// The log flags and other elemets come from stdlib's log package. This is the
// relevant copyright notice:
// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package ezlog provides simple leveled log output using stdlib's log.Logger.
// A type Logger is defined with methods for leveled log line and formatted
// leveled log line output. For convenience, a 'standard' logger is available
// through the helper functions. The 'standard' logger's log level is LogError
// and writes output to stderr with LstdFlags.
//
// In addition to LogNone, which discards all log lines, three common log
// levels are supported: error (LogError), info (LogInfo), and debug
// (LogDebug). Any log lines that are for log levels higher than the Logger's
// set log level are discarded.
//
// Logger methods for generating output generate log line with either the Level
// string, or the first character of the Level string, depending on if UseChar
// has been set to true. Fatal function calls will result in FATAL, or F, being
// added to the generated log line. Panic function calls will result in PANIC,
// or P, being added to the generated log line.
package ezlog

import (
	"fmt"
	"io"
	"log"
	"os"
	"strings"
	"sync/atomic"
)

// These flags define which text to prefix to each log entry generated by the Logger.
const (
	// Bits or'ed together to control what's printed.
	// There is no control over the order they appear (the order listed
	// here) or the format they present (as described in the comments).
	// The prefix is followed by a colon only when Llongfile or Lshortfile
	// is specified.
	// For example, flags Ldate | Ltime (or LstdFlags) produce,
	//	2009/01/23 01:23:23 message
	// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
	//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

// Level: log levels.
type Level int32 // for sync.Atomic.Int32

const (
	LogNone  Level = iota + 1 // No logging.
	LogError                  // Log Error lines.
	LogInfo                   // Log Info and Error lines.
	LogDebug                  // Log Debug, Info, and Error lines.
	logFatal
	logPanic
)

var levelChar = []string{
	LogNone:  "NONE: ", // this is the fullword because it should never be used
	LogError: "E: ",
	LogInfo:  "I: ",
	LogDebug: "D: ",
	logFatal: "F: ",
	logPanic: "P: ",
}

var levelName = []string{
	LogNone:  "NONE: ",
	LogError: "ERROR: ",
	LogInfo:  "INFO: ",
	LogDebug: "DEBUG: ",
	logFatal: "FATAL: ",
	logPanic: "PANIC: ",
}

func (l Level) String() string {
	return levelName[l]
}

// Get the Level corresponding to s. A false will be returned if s doesn't
// match any Levels.
func LevelByName(s string) (level Level, ok bool) {
	v := strings.ToUpper(s)
	switch v {
	case "NONE":
		return LogNone, true
	case "ERROR":
		return LogError, true
	case "INFO":
		return LogInfo, true
	case "DEBUG":
		return LogDebug, true
	default:
		return 0, false
	}
}

// UnknownFlagError occurs when a string cannot be parsed into a log Flag.
type UnknownFlagError struct {
	S string // The string that could not be parsed to a valid Flag.
}

func (e UnknownFlagError) Error() string {
	return "unknown log flag: " + e.S
}

// ParseLogFlag returns the log Flag for s. UnknownFlagError is returned if no
// match is found. A match is found when s is equal to either the name of a
// Flag constant or the name of a Flag constant without the leading 'l', e.g.
// both "lstdflags" and "stdflags" will return the value for the LstdFlags
// constant. The match is case-insensitve.
func ParseLogFlag(s string) (l int, err error) {
	v := strings.ToLower(s)
	switch v {
	case "ldate", "date":
		return Ldate, nil
	case "ltime", "time":
		return Ltime, nil
	case "lmicroseconds", "microseconds":
		return Lmicroseconds, nil
	case "llongfile", "longfile":
		return Llongfile, nil
	case "lshortfile", "shortfile":
		return Lshortfile, nil
	case "lutc", "utc":
		return LUTC, nil
	case "lstdflags", "stdflags":
		return LstdFlags, nil
	case "none":
		return 0, nil
	}
	return 0, UnknownFlagError{s}
}

// Logger: generates leveled log lines of output to an io.Writer if the log
// level is <= the logger's level. This is safe for concurrent use.
type Logger struct {
	l       *log.Logger
	level   Level
	useChar int32 // treated as a bool using Go's definiton for true/false; sync.AtomicInt32
}

// New creates a new Logger. The level argument sets the Logger's log level.
// The out argument sets the log data output destination. The prefix argument
// sets what each line will start with. The flag argument sets the logger's
// properties.
func New(level Level, out io.Writer, prefix string, flag int) *Logger {
	return &Logger{l: log.New(out, prefix, flag), level: level, useChar: 1}
}

// Error writes an error entry. If the logger's level is less than LogError,
// the line will be discarded.
func (l *Logger) Error(v ...interface{}) {
	if l.level < LogError {
		return
	}
	v = append([]interface{}{l.levelString(LogError)}, v...)
	l.l.Print(v...)
}

// Errorf writes an error entry using the provided format and data. If the
// level is less than LogError, the line will be discarded. Arguments are
// handled in the manner of fmt.Printf.
func (l *Logger) Errorf(format string, v ...interface{}) {
	if l.level < LogError {
		return
	}
	l.l.Printf(fmt.Sprintf("%s%s", l.levelString(LogError), format), v...)
}

// Info writes an info entry. If the level is less than LogInfo, the line will
// be discarded.
func (l *Logger) Info(v ...interface{}) {
	if l.level < LogInfo {
		return
	}
	v = append([]interface{}{l.levelString(LogInfo)}, v...)
	l.l.Print(v...)
}

// Infof writes an info entry using the provided format and data. If the level
// is less than LogInfo, the line will be discarded. Arguments are handled in
// the manner of fmt.Printf.
func (l *Logger) Infof(format string, v ...interface{}) {
	if l.level < LogInfo {
		return
	}
	l.l.Printf(fmt.Sprintf("%s%s", l.levelString(LogInfo), format), v...)
}

// Debug writes a debug entry to the log. If the level is less than LogDebug,
// the line will be discarded.
func (l *Logger) Debug(v ...interface{}) {
	if l.level < LogDebug {
		return
	}
	v = append([]interface{}{l.levelString(LogDebug)}, v...)
	l.l.Print(v...)
}

// Debugf writes a debug entry to the log using the provided format and data.
// If the level is less than LogDebug, the line will be discarded. Arguments
// are handled in the manner of fmt.Printf.
func (l *Logger) Debugf(format string, v ...interface{}) {
	if l.level < LogDebug {
		return
	}
	l.l.Printf(fmt.Sprintf("%s%s", l.levelString(LogDebug), format), v...)
}

// Fatal writes a fatal entry to the log followed by a call to os.Exit(1).
func (l *Logger) Fatal(v ...interface{}) {
	v = append([]interface{}{l.levelString(logFatal)}, v...)
	l.l.Fatal(v...)
}

// Fatalf writes a fatal entry to the log using the provided format and data
// followed by a call to os.Exit(1).
func (l *Logger) Fatalf(format string, v ...interface{}) {
	l.l.Fatalf(fmt.Sprintf("%s%s", l.levelString(logFatal), format), v...)
}

// Panic writes a panic entry to the log followed by a call to panic().
func (l *Logger) Panic(v ...interface{}) {
	v = append([]interface{}{l.levelString(LogDebug)}, v...)
	l.l.Panic(v...)
}

// Panicf writes a panic entry to the log using the provided format and data
// followed by a call to panic().
func (l *Logger) Panicf(format string, v ...interface{}) {
	l.l.Panicf(fmt.Sprintf("%s%s", l.levelString(logPanic), format), v...)
}

// UseChar sets if the logger's log line should use the first character of the
// Level name. When false, the default, the full name of the Level will be
// used.
func (l *Logger) UseChar(b bool) {
	var i int32
	if !b {
		i = 1 // For Go, false is defined as 0 != 0
	}
	atomic.StoreInt32(&l.useChar, i)
}

// SetLevel sets the maximum level for log output. Any log lines higher than
// the Level will be discarded.
func (l *Logger) SetLevel(i Level) {
	atomic.StoreInt32((*int32)(&l.level), int32(i))
}

func (l *Logger) levelString(i Level) string {
	if l.useChar == 0 {
		return levelChar[i]
	}
	return levelName[i]
}

// Flags returns the logger's output flags.
func (l *Logger) Flags() int {
	return l.l.Flags()
}

// Prefix returns the logger's prefix.
func (l *Logger) Prefix() string {
	return l.l.Prefix()
}

// Setflags sets the logger's flags.
func (l *Logger) SetFlags(flags int) {
	l.l.SetFlags(flags)
}

// SetPrefix sets the logger's prefix.
func (l *Logger) SetPrefix(prefix string) {
	l.l.SetPrefix(prefix)
}

// Set the logger output.
func (l *Logger) SetOutput(w io.Writer) {
	l.l.SetOutput(w)
}

var std = New(LogError, os.Stderr, "", log.LstdFlags)

// Error writes an error entry. If the logger's level is less than LogError,
// the line will be discarded.
func Error(v ...interface{}) {
	std.Error(v...)
}

// Errorf writes an error entry using the provided format and data. If the
// level is less than LogError, the line will be discarded. Arguments are
// handled in the manner of fmt.Printf.
func Errorf(format string, v ...interface{}) {
	std.Errorf(format, v...)
}

// Info writes an info entry. If the level is less than LogInfo, the line will
// be discarded.
func Info(v ...interface{}) {
	std.Info(v...)
}

// Infof writes an info entry using the provided format and data. If the level
// is less than LogInfo, the line will be discarded. Arguments are handled in
// the manner of fmt.Printf.
func Infof(format string, v ...interface{}) {
	std.Infof(format, v...)
}

// Debug writes a debug entry to the log. If the level is less than LogDebug,
// the line will be discarded.
func Debug(v ...interface{}) {
	std.Debug(v...)
}

// Debugf writes a debug entry to the log using the provided format and data.
// If the level is less than LogDebug, the line will be discarded. Arguments
// are handled in the manner of fmt.Printf.
func Debugf(format string, v ...interface{}) {
	std.Debugf(format, v...)
}

// Fatal writes a fatal entry to the log followed by a call to os.Exit(1).
func Fatal(v ...interface{}) {
	std.Fatal(v...)
}

// Fatalf writes a fatal entry to the log using the provided format and data
// followed by a call to os.Exit(1).
func Fatalf(format string, v ...interface{}) {
	std.Fatalf(format, v...)
}

// Panic writes a fatal entry to the log followed by a call to panic().
func Panic(v ...interface{}) {
	std.Panic(v...)
}

// Panicf writes a panic entry to the log using the provided format and data
// followed by a call to panic().
func Panicf(format string, v ...interface{}) {
	std.Panicf(format, v...)
}

// UseChar sets if the standard logger's log line should use the first
// character of the Level name. When false, the default, the full name of the
// Level will be used.
func UseChar(b bool) {
	std.UseChar(b)
}

// SetLevel sets the maximum level for the standard logger's log output. Any
// log lines higher that the Level will be discarded.
func SetLevel(i Level) {
	std.SetLevel(i)
}

// Flags returns the standard logger's output flags.
func Flags() int {
	return std.l.Flags()
}

// Prefix returns the standrd logger's prefix.
func Prefix() string {
	return std.l.Prefix()
}

// SetFlags sets the standard logger's flags.
func SetFlags(flags int) {
	std.l.SetFlags(flags)
}

// SetPrefix sets the standard logger's prefix.
func SetPrefix(prefix string) {
	std.l.SetPrefix(prefix)
}

// SetOutput sets the standard logger's output destination.
func SetOutput(w io.Writer) {
	std.SetOutput(w)
}
